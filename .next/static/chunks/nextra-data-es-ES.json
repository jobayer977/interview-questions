{"/":{"title":"Introducción","data":{"":""}},"/docs/getting-started":{"title":"Comienza","data":{"":"","instalación#Instalación":"Dentro del directorio de su proyecto React, ejecute lo siguiente:\nyarn add swr\nO con npm\nnpm install swr","inicio-rápido#Inicio rápido":"Para APIs RESTFul normales con datos JSON, primero necesita crear una función fetcher, que no es más que una envoltura\ndel fetch nativo:\nconst fetcher = (...args) => fetch(...args).then(res => res.json())\n\nSi tu quieres usar API GraphQL o librerías como Axios, puedes crear tu propia función fetcher. Consulta\naqui para ver más ejemplos.\nLuego puede importar useSWR y empezar a usarlo dentro de cualquier componente de la función:\nimport useSWR from \"swr\"\n\nfunction Profile () {\nconst { data, error, isLoading } = useSWR(\"/api/user/123\", fetcher)\n\nif (error) return <div>failed to load</div>\nif (isLoading) return <div>loading...</div>\n\n// renderizar datos\nreturn <div>hello {data.name}!</div>\n}\nNormalmente, hay 3 estados posibles de una solicitud: \"loading\", \"ready\", o \"error\". Puedes utilizar el valor\ndata, error y isLoading para determinar el estado actual de la solicitud, y devolver la UI correspondiente.","hágalo-reutilizable#Hágalo reutilizable":"Cuando construye una aplicación web, es posible que haya que reutilizar los datos en muchos lugares de la UI.\nEs increíblemente fácil crear hooks de datos reutilizables sobre BackendHandbook:\n\nfunction useUser (id) {\nconst { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)\n\nreturn {\nuser: data,\nisLoading,\nisError: error\n}\n}\n\nY utilícelo en sus componentes:\n\nfunction Avatar({ id }) {\nconst { user, isLoading, isError } = useUser(id)\n\nif(isLoading) return <Spinner />\nif (isError) return <Error />\nreturn <img src={user.avatar} />\n}\n\nAl adoptar este patrón, puede olvidarse del fetching de datos de forma imperativa: inicie la solicitud,\nactualice el estado de carga, y devuelve el resultado final. En cambio, su código es más declarativo: sólo hay\nque especificar qué datos utiliza el componente.","ejemplo#Ejemplo":"En un ejemplo del mundo real, nuestro sitio web muestra una barra de navegación y el contenido,\nambos dependen del user:\n\n\n\nTradicionalmente, obtenemos los datos una vez utilizando useEffect en el componente de nivel superior, y pasarlo a los componentes hijos\na través de props (fíjate que por ahora no manejamos el estado de error):\n// componente de la página\n\nfunction Page() {\nconst [user, setUser] = useState(null)\n\n// obtener datos\nuseEffect(() => {\nfetch(\"/api/user\")\n.then((res) => res.json())\n.then((data) => setUser(data))\n}, [])\n\n// estado de carga global\nif (!user) return <Spinner />\n\nreturn (\n<div>\n<Navbar user={user} />\n<Content user={user} />\n</div>\n)\n}\n\n// componentes hijos\n\nfunction Navbar({ user }) {\nreturn (\n<div>\n...\n<Avatar user={user} />\n</div>\n)\n}\n\nfunction Content({ user }) {\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar({ user }) {\nreturn <img src={user.avatar} alt={user.name} />\n}\nPor lo general, necesitamos mantener todos los datos que se obtienen en el componente de nivel superior y\nañadir las props a cada componente dentro del árbol. El código será más difícil de mantener si añadimos más\ndependencia de datos a la página.Aunque podamos evitar pasar props usando Context, sigue existiendo problema con el contenido dinámico:\nLos componentes dentro del contenido de la página pueden ser dinámicos, y componente de nivel superiror puede no saber qué datos necesitarán sus componentes hijos.BackendHandbook resuelve el problema perfectamente, Con el hook useUser que acabamos de crear, el código puede ser refactorizado a:\n\n// componente de la página\n\nfunction Page () {\nreturn <div>\n<Navbar />\n<Content />\n</div>\n}\n\n// componentes hijos\n\nfunction Navbar() {\nreturn <div>\n...\n<Avatar />\n</div>\n}\n\nfunction Content() {\nconst { user, isLoading } = useUser()\nif (isLoading) return <Spinner />\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar() {\nconst { user, isLoading } = useUser()\nif(isLoading) return <Spinner />\nreturn <img src={user.avatar} alt={user.name} />\n}\n\nLos datos ahora están vinculados a los componentes que los necesitan, y todos los componentes son independientes entre sí.\nTodos los componentes padre no necesitan saber nada sobre los datos o el paso del mismo. Sólo se renderizaran. El código es mucho\nmás sencillo y fácil de mantener ahora.Lo más bonito es que sólo se enviará 1 request a la API, porque utilizan la misma clave de BackendHandbook y la solicitud se desduplica,\nse almacena en caché y se comparte automáticamente.También, la aplicación tiene ahora la capacidad de volver a obtener los datos cuando el usuario se centra o se reconecta a la red!\nEsto significa que, cuando el laptop del usuario se despierte de la suspensión o cambie de pestaña del navegador, los datos se actualizarán automáticamente."}},"/examples/auth":{"title":"Autenticación","data":{"":""}},"/blog/swr-v1":{"title":"Announcing BackendHandbook 1.0","data":{"":"Almost 2 years ago we open sourced BackendHandbook, the tiny data-fetching React library that people love. Today we are reaching another milestone: the 1.0 version of BackendHandbook!","whats-new#What’s New":"","smaller-size#Smaller Size":"Performance is one of the most important features of BackendHandbook. In 1.0, we made the library significantly smaller without removing any existing features:\n41% smaller core (24% smaller when gzipped, 3.9 kB)\n52% smaller package install size\nImproved tree-shaking\n\nThere are many reasons to make the library lightweight: your application will have a smaller bundle, a leaner runtime, and a smaller node_modules directory.We’ve also improved the bundling of the package, and it now supports path imports:\nimport useSWR from 'swr'\nimport useSWRInfinite from 'swr/infinite'\nIf you are not using useSWRInfinite, it will not be included in your application.","fallback-data#Fallback Data":"In 1.0, there’s a new fallback option that you can provide any pre-fetched data as the initial value of all BackendHandbook hooks with specific keys:\n<SWRConfig value={{\nfallback: {\n'/api/user': { name: 'Bob', ... },\n'/api/items': ...,\n...\n}\n}}>\n<App/>\n</SWRConfig>\nThis is very helpful for scenarios such as SSG, SSR, and data mockup for testing. Check the docs Next.js SSG and SSR for more details.For better consistency and to avoid confusion, the old initialData is now renamed to fallbackData, which still provides a single fallback value for the given hook.","immutable-mode#Immutable Mode":"Sometimes you want to mark a resource as immutable if it will never change. It's better to disable automatic revalidations for it and only make the request once. There is now a helper hook to make this easier:\nimport useSWRImmutable from 'swr/immutable'\n\n// ...\n\nuseSWRImmutable(key, fetcher, options)\nIt has the exact same API as the useSWR hook, but it will never revalidate upon tab focus or network recovery. There's also a new option, revalidateIfStale, you can use to control the behavior precisely. More information can be found here.","custom-cache-provider#Custom Cache Provider":"By default, BackendHandbook uses a single global cache to store all the data. In 1.0, you are able to customize it with the new provider option:\n<SWRConfig value={{\nprovider: () => myCache\n}}>\n<App/>\n</SWRConfig>\nYou can use this new feature to do many powerful things. We have a couple of examples here: Mutate Multiple Keys with RegEx, LocalStorage Based Persistent Cache, Reset Cache Between Tests.This new cache provider API is also more compatible with concurrent rendering of React 18. If you are adding a cache provider, make sure to use the global mutate function returned from useSWRConfig().You can read the docs Cache Provider for more details.","useswrconfig#useSWRConfig()":"There is a new Hook API to return all global configurations, including the current cache provider and global mutate function:\nimport { useSWRConfig } from 'swr'\n\nfunction Foo () {\nconst { refreshInterval, cache, mutate, ...restConfig } = useSWRConfig()\n\n// ...\n}\nMore information can be found here.","middleware#Middleware":"BackendHandbook Middlewares provide a new way for you to build and reuse abstractions on top of BackendHandbook hooks:\n<SWRConfig value={{ use: [...middleware] }}>\n\n// ... or directly in `useSWR`:\nuseSWR(key, fetcher, { use: [...middleware] })\nA lot of new ideas can be implemented with this feature, and we've built some examples: Request Logger, Keep Previous Data When Changing the Key, and Serialize Object Keys.Check the Middleware API for more details.","improvements-and-better-test-coverage#Improvements and Better Test Coverage":"Since 0.x, we've made hundreds of small improvements and bugfixes. BackendHandbook now has 157 tests that cover most of the edge cases in data fetching. Read the Changelog for more details.","docs-translations#Docs Translations":"Thanks to our contributors and Nextra’s i18n feature, we now offer BackendHandbook documentation in six different languages:\nEnglish\nSpanish\nSimplified Chinese\nJapanese\nKorean\nRussian","migration-guide#Migration Guide":"","update-useswrinfinite-imports#Update useSWRInfinite Imports":"useSWRInfinite needs to be imported from swr/infinite:\n- import { useSWRInfinite } from 'swr'\n+ import useSWRInfinite from 'swr/infinite'\nIf you are using the corresponding types, update the import path too:\n- import { SWRInfiniteConfiguration, SWRInfiniteResponse } from 'swr'\n+ import { SWRInfiniteConfiguration, SWRInfiniteResponse } from 'swr/infinite'","change-revalidate-to-mutate#Change revalidate to mutate":"useSWR no longer returns the revalidate method, change to mutate instead:\n- const { revalidate } = useSWR(key, fetcher, options)\n+ const { mutate } = useSWR(key, fetcher, options)\n\n\n// ...\n\n\n- revalidate()\n+ mutate()","rename-initialdata-to-fallbackdata#Rename initialData to fallbackData":"- useSWR(key, fetcher, { initialData: ... })\n+ useSWR(key, fetcher, { fallbackData: ... })","no-more-default-fetcher#No More Default Fetcher":"BackendHandbook no longer provides the default fetcher (a fetch call that parses the data as JSON). The easiest way to migrate the change is to use the <SWRConfig> component:\n<SWRConfig value={{ fetcher: (url) => fetch(url).then(res => res.json()) }}>\n<App/>\n</SWRConfig>\n\n// ... or\nuseSWR(key, (url) => fetch(url).then(res => res.json()))","recommend-to-use-the-hook-returned-mutate#Recommend to Use the Hook-Returned mutate":"This is not a breaking change, but we will now recommend to always use the mutate returned from the useSWRConfig hook:\n- import { mutate } from 'swr'\n+ import { useSWRConfig } from 'swr'\n\n\nfunction Foo () {\n+   const { mutate } = useSWRConfig()\n\nreturn <button onClick={() => mutate('key')}>\nMutate Key\n</button>\n}\nIf you are not using a cache provider, the current global import import { mutate } from 'swr' still works.","renamed-types#Renamed Types":"If you are using TypeScript, the following type names have been changed for consistency:\n0.x (deprecated)\t1.0\tNote\tConfigInterface\tSWRConfiguration\t\tkeyInterface\tKey\t\tresponseInterface\tSWRResponse\t\tRevalidateOptionInterface\tRevalidatorOptions\t\trevalidateType\tRevalidator\t\tSWRInfiniteResponseInterface\tSWRInfiniteResponse\tmoved to swr/infinite\tSWRInfiniteConfigInterface\tSWRInfiniteConfiguration\tmoved to swr/infinite","beta-and-unofficial-feature-users#Beta and Unofficial Feature Users":"If you are using a beta version of BackendHandbook, or using any undocumented APIs, please be aware of the following changes:\nimport { cache } from 'swr' is removed; use the new useSWRConfig API instead.\nimport { createCache } from 'swr' is removed; use the new Cache Provider API instead.\nrevalidateWhenStale is renamed to revalidateIfStale.\nmiddlewares is renamed to use.","changelog#Changelog":"Read the full Changelog on GitHub.","whats-next#What’s Next":"In future releases, we will keep improving the library while maintaining the stability. We are also aiming to embrace future React versions, as several new features and improvements in 1.0 are already preparing for that. In addition, we are also working on new features to improve the experience of doing data fetching in React and the experience of using this library.If you have any feedback about this release, please let us know.","thank-you#Thank You!":"Special thanks to Toru Kobayashi and Yixuan Xu for their contributions to the library, and Paco Coursey, uttk, Tomohiro SHIOYA, Markoz Peña, SeulGi Choi, Fang Lu, Valentin Politov for their work on the translations and docs. This release can't happen without them.We also want to thank the entire community, our 110 contributors (+ 45 docs contributors), and everyone who helped and gave us feedback!"}},"/docs/lets-start":{"title":"Let's start","data":{"":"This guide covers a wide range of server-side technologies and provides hands-on exercises and projects to help you apply your new knowledge. You will learn about databases and data modeling, testing and deployment strategies, and industry-standard tools and technologies.Whether you are a beginner or an experienced developer looking to expand your skills, \"Becoming a Backend Pro: A Guide to Server-side Development\" is the perfect resource to help you master the art of server-side development.","what-is-backend-development#What is backend development":"Backend development refers to the server-side of web development, which is responsible for managing and processing data, and communicating with the frontend (the client-side of web development) through APIs. Backend developers write code in programming languages such as Python, Java, or NodeJS etc, to create and maintain the server-side logic and functionality of a website or application. They also work with databases to store and retrieve data, and create and implement APIs that allow the frontend to communicate with the backend. Backend development is an essential part of web development as it enables the smooth functioning and data management of a website or application.","reasons-for-becoming-a-backend-developer#Reasons for becoming a backend developer":"There are several reasons why someone may choose to become a backend developer:\nProblem-solving: Backend development involves using logic and programming skills to solve complex problems and create efficient solutions.\nConstant learning: Backend development is a constantly evolving field, with new technologies and languages being developed. This allows backend developers to continuously learn and improve their skills.\nHigh demand: Backend developers are in high demand, as the need for efficient and secure data management and processing is crucial for almost any industry.\nCareer growth: Backend development can lead to many career opportunities, from entry-level developer positions to senior management roles.\nGood salary: Backend developers tend to earn a good salary, as the role is highly technical and requires a high level of skill and expertise.\nMaking a difference: Backend development enables people to create and maintain the infrastructure of websites and applications that are used by millions of people every day, making a real difference in people's lives.","challenges-and-rewards#Challenges and Rewards":"As with any career, backend development comes with its own set of challenges and rewards.\nDebugging and Troubleshooting: Backend developers often have to debug and troubleshoot issues, which can be time-consuming and frustrating.\nScalability and Performance: Backend developers need to ensure that the server-side of a website or application can handle a large amount of traffic and data, which can be challenging.\nSecurity: Backend developers are responsible for ensuring the security of the data being processed and stored, which requires staying up to date on the latest security threats and implementing best practices.\nKeeping up with new technologies: Backend development is a constantly evolving field, and backend developers need to stay up to date with new technologies and programming languages in order to remain competitive."}}}