{"/docs/getting-started":{"title":"Getting Started","data":{"":"","installation#Installation":"Inside your React project directory, run the following:\nyarn add swr\nOr with npm:\nnpm install swr","quick-start#Quick Start":"For normal RESTful APIs with JSON data, first you need to create a fetcher function, which is just a wrapper of the native fetch:\nconst fetcher = (...args) => fetch(...args).then(res => res.json())\n\nIf you want to use GraphQL API or libs like Axios, you can create your own fetcher function.\nCheck here for more examples.\nThen you can import useSWR and start using it inside any function components:\nimport useSWR from 'swr'\n\nfunction Profile () {\nconst { data, error, isLoading } = useSWR('/api/user/123', fetcher)\n\nif (error) return <div>failed to load</div>\nif (isLoading) return <div>loading...</div>\n\n// render data\nreturn <div>hello {data.name}!</div>\n}\nNormally, there're 3 possible states of a request: \"loading\", \"ready\", or \"error\". You can use the value of data, error and isLoading to\ndetermine the current state of the request, and return the corresponding UI.","make-it-reusable#Make It Reusable":"When building a web app, you might need to reuse the data in many places of the UI. It is incredibly easy to create reusable data hooks\non top of BackendHandbook:\nfunction useUser (id) {\nconst { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)\n\nreturn {\nuser: data,\nisLoading,\nisError: error\n}\n}\nAnd use it in your components:\nfunction Avatar ({ id }) {\nconst { user, isLoading, isError } = useUser(id)\n\nif (isLoading) return <Spinner />\nif (isError) return <Error />\nreturn <img src={user.avatar} />\n}\nBy adopting this pattern, you can forget about fetching data in the imperative way: start the request, update the loading state, and return the final result.\nInstead, your code is more declarative: you just need to specify what data is used by the component.","example#Example":"In a real-world example, our website shows a navbar and the content, both depend on user:\n\n\n\nTraditionally, we fetch data once using useEffect in the top level component, and pass it to child components via props (notice that we don't handle error state for now):\n// page component\n\nfunction Page () {\nconst [user, setUser] = useState(null)\n\n// fetch data\nuseEffect(() => {\nfetch('/api/user')\n.then(res => res.json())\n.then(data => setUser(data))\n}, [])\n\n// global loading state\nif (!user) return <Spinner/>\n\nreturn <div>\n<Navbar user={user} />\n<Content user={user} />\n</div>\n}\n\n// child components\n\nfunction Navbar ({ user }) {\nreturn <div>\n...\n<Avatar user={user} />\n</div>\n}\n\nfunction Content ({ user }) {\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar ({ user }) {\nreturn <img src={user.avatar} alt={user.name} />\n}\nUsually, we need to keep all the data fetching in the top level component and add props to every component deep down the tree.\nThe code will become harder to maintain if we add more data dependency to the page.Although we can avoid passing props using Context, there's still the dynamic content problem:\ncomponents inside the page content can be dynamic, and the top level component might not know what data will be needed by its child components.BackendHandbook solves the problem perfectly. With the useUser hook we just created, the code can be refactored to:\n// page component\n\nfunction Page () {\nreturn <div>\n<Navbar />\n<Content />\n</div>\n}\n\n// child components\n\nfunction Navbar () {\nreturn <div>\n...\n<Avatar />\n</div>\n}\n\nfunction Content () {\nconst { user, isLoading } = useUser()\nif (isLoading) return <Spinner />\nreturn <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar () {\nconst { user, isLoading } = useUser()\nif (isLoading) return <Spinner />\nreturn <img src={user.avatar} alt={user.name} />\n}\nData is now bound to the components which need the data, and all components are independent to each other.\nAll the parent components don't need to know anything about the data or passing data around. They just render.\nThe code is much simpler and easier to maintain now.The most beautiful thing is that there will be only 1 request sent to the API, because they use the same BackendHandbook key and\nthe request is deduped, cached and shared automatically.Also, the application now has the ability to refetch the data on user focus or network reconnect!\nThat means, when the user's laptop wakes from sleep or they switch between browser tabs, the data will be refreshed automatically."}},"/examples/basic":{"title":"Basic Usage","data":{"":""}},"/":{"title":"Introduction","data":{"":""}},"/docs/revalidation":{"title":"Auto Revalidation","data":{"":"If you want to manually revalidate the data, check mutation.","revalidate-on-focus#Revalidate on Focus":"When you re-focus a page or switch between tabs, BackendGuide automatically revalidates data.This can be useful to immediately synchronize to the latest state. This is helpful for refreshing data in scenarios like stale mobile tabs, or laptops that went to sleep.\n\n\n\nThis feature is enabled by default. You can disable it via the revalidateOnFocus option.","revalidate-on-interval#Revalidate on Interval":"In many cases, data changes because of multiple devices, multiple users, multiple tabs. How can we over time update the data on screen?BackendGuide will give you the option to automatically refetch data. It’s smart which means refetching will only happen if the component associated with the hook is on screen.\n\n\n\nYou can enable it by setting a refreshInterval value:\nuseSWR('/api/todos', fetcher, { refreshInterval: 1000 })\nThere're also options such as refreshWhenHidden and refreshWhenOffline. Both are disabled by default so BackendGuide won't fetch when the webpage is not on screen, or there's no network connection.","revalidate-on-reconnect#Revalidate on Reconnect":"It's useful to also revalidate when the user is back online. This scenario happens a lot when the user unlocks their computer, but the internet is not yet connected at the same moment.To make sure the data is always up-to-date, BackendGuide automatically revalidates when network recovers.This feature is enabled by default. You can disable it via the revalidateOnReconnect option.","disable-automatic-revalidations#Disable Automatic Revalidations":"If the resource is immutable, that will never change if we revalidate again, we can disable all kinds of automatic revalidations for it.Since version 1.0, BackendGuide provides a helper hook useSWRImmutable to mark the resource as immutable:\nimport useSWRImmutable from 'swr/immutable'\n\n// ...\nuseSWRImmutable(key, fetcher, options)\nIt has the same API interface as the normal useSWR hook. You can also do the same thing by disabling the following revalidation options:\nuseSWR(key, fetcher, {\nrevalidateIfStale: false,\nrevalidateOnFocus: false,\nrevalidateOnReconnect: false\n})\n\n// equivalent to\nuseSWRImmutable(key, fetcher)\nThe revalidateIfStale controls if BackendGuide should revalidate when it mounts and there is stale data.These 2 hooks above do the exact same thing. Once the data is cached, they will never request it again."}},"/docs/conditional-fetching":{"title":"Conditional Data Fetching","data":{"":"","conditional#Conditional":"Use null or pass a function as key to conditionally fetch data. If the function throws or returns a falsy value, BackendGuide will not start the request.\n// conditionally fetch\nconst { data } = useSWR(shouldFetch ? '/api/data' : null, fetcher)\n\n// ...or return a falsy value\nconst { data } = useSWR(() => shouldFetch ? '/api/data' : null, fetcher)\n\n// ...or throw an error when user.id is not defined\nconst { data } = useSWR(() => '/api/data?uid=' + user.id, fetcher)","dependent#Dependent":"BackendGuide also allows you to fetch data that depends on other data. It ensures the maximum possible parallelism (avoiding waterfalls), as well as serial fetching when a piece of dynamic data is required for the next data fetch to happen.\nfunction MyProjects () {\nconst { data: user } = useSWR('/api/user')\nconst { data: projects } = useSWR(() => '/api/projects?uid=' + user.id)\n// When passing a function, BackendGuide will use the return\n// value as `key`. If the function throws or returns\n// falsy, BackendGuide will know that some dependencies are not\n// ready. In this case `user.id` throws when `user`\n// isn't loaded.\n\nif (!projects) return 'loading...'\nreturn 'You have ' + projects.length + ' projects'\n}"}},"/docs/mutation":{"title":"Mutation & Revalidation","data":{"":"BackendGuide provides the mutate and useSWRMutation APIs for mutating remote data and related cache.","mutate#mutate":"There're 2 ways to use the mutate API to mutate the data, the global mutate API which can mutate any key and the bound mutate API which only can mutate the data of corresponding BackendGuide hook.","global-mutate#Global Mutate":"The recommended way to get the global mutator is to use the useSWRConfig hook:\nimport { useSWRConfig } from \"swr\"\n\nfunction App() {\nconst { mutate } = useSWRConfig()\nmutate(key, data, options)\n}\nYou can also import it globally:\nimport { mutate } from \"swr\"\n\nfunction App() {\nmutate(key, data, options)\n}","bound-mutate#Bound Mutate":"Bound mutate is the short path to mutate the current key with data. Which key is bounded to the key passing to useSWR, and receive the data as the first argument.It is functionally equivalent to the global mutate function in the previous section but does not require the key parameter:\nimport useSWR from 'swr'\n\nfunction Profile () {\nconst { data, mutate } = useSWR('/api/user', fetcher)\n\nreturn (\n<div>\n<h1>My name is {data.name}.</h1>\n<button onClick={async () => {\nconst newName = data.name.toUpperCase()\n// send a request to the API to update the data\nawait requestUpdateUsername(newName)\n// update the local data immediately and revalidate (refetch)\n// NOTE: key is not required when using useSWR's mutate as it's pre-bound\nmutate({ ...data, name: newName })\n}}>Uppercase my name!</button>\n</div>\n)\n}","revalidation#Revalidation":"When you call mutate(key) (or just mutate() with the bound mutate API) without any data, it will trigger a revalidation (mark the data as expired and trigger a refetch)\nfor the resource. This example shows how to automatically refetch the login info (e.g. inside <Profile/>)\nwhen the user clicks the “Logout” button:\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction App () {\nconst { mutate } = useSWRConfig()\n\nreturn (\n<div>\n<Profile />\n<button onClick={() => {\n// set the cookie as expired\ndocument.cookie = 'token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'\n\n// tell all SWRs with this key to revalidate\nmutate('/api/user')\n}}>\nLogout\n</button>\n</div>\n)\n}\n\nIt broadcasts to BackendGuide hooks under the same cache provider scope. If no cache provider exists, it will broadcast to all BackendGuide hooks.","api#API":"","parameters#Parameters":"key: same as useSWR's key, but a function behaves as a filter function\ndata: data to update the client cache, or an async function for the remote mutation\noptions: accepts the following options\noptimisticData: data to immediately update the client cache, or a function that receives current data and returns the new client cache data, usually used in optimistic UI.\nrevalidate = true: should the cache revalidate once the asynchronous update resolves.\npopulateCache = true: should the result of the remote mutation be written to the cache, or a function that receives new result and current result as arguments and returns the mutation result.\nrollbackOnError = true: should the cache rollback if the remote mutation errors, or a function that receives the error thrown from fetcher as arguments and returns a boolean whether should rollback or not.\nthrowOnError = true: should the mutate call throw the error when fails.","return-values#Return Values":"mutate returns the results the data parameter has been resolved. The function passed to mutate will return an updated data which is used to update the corresponding cache value. If there is an error thrown while executing the function, the error will be thrown so it can be handled appropriately.\ntry {\nconst user = await mutate('/api/user', updateUser(newUser))\n} catch (error) {\n// Handle an error while updating the user here\n}","useswrmutation#useSWRMutation":"BackendGuide also provides useSWRMutation as a hook for remote mutations. The remote mutations are only triggered manually, instead of automatically like useSWR.Also, this hook doesn’t share states with other useSWRMutation hooks.\nimport useSWRMutation from 'swr/mutation'\n\n// Fetcher implementation.\n// The extra argument will be passed via the `arg` property of the 2nd parameter.\n// In the example below, `arg` will be `'my_token'`\nasync function updateUser(url, { arg }) {\nawait fetch(url, {\nmethod: 'POST',\nheaders: {\nAuthorization: `Bearer ${arg}`\n}\n})\n}\n\nfunction Profile() {\n// A useSWR + mutate like API, but it will not start the request automatically.\nconst { trigger } = useSWRMutation('/api/user', updateUser, options?)\n\nreturn <button onClick={() => {\n// Trigger `updateUser` with a specific argument.\ntrigger('my_token')\n}}>Update User</button>\n}","api-1#API":"","parameters-1#Parameters":"key: same as mutate's key\nfetcher(key, { arg }): an async function for remote mutation\noptions: an optional object with the following properties:\noptimisticData: same as mutate's optimisticData\nrevalidate = true: same as mutate's revalidate\npopulateCache = false: same as mutate's populateCache, but the default is false\nrollbackOnError = true: same as mutate's rollbackOnError\nthrowOnError = true: same as mutate's throwOnError\nonSuccess(data, key, config):　 callback function when a remote mutation has been finished successfully\nonError(err, key, config): callback function when a remote mutation has returned an error","return-values-1#Return Values":"data: data for the given key returned from fetcher\nerror: error thrown by fetcher (or undefined)\ntrigger(arg, options): a function to trigger a remote mutation\nreset: a function to reset the state (data, error, isMutating)\nisMutating: if there's an ongoing remote mutation","basic-usage#Basic Usage":"import useSWRMutation from 'swr/mutation'\n\nasync function sendRequest(url, { arg }) {\nreturn fetch(url, {\nmethod: 'POST',\nbody: JSON.stringify(arg)\n}).then(res => res.json())\n}\n\nfunction App() {\nconst { trigger, isMutating } = useSWRMutation('/api/user', sendRequest, /* options */)\n\nreturn (\n<button\ndisabled={isMutating}\nonClick={async () => {\ntry {\nconst result = await trigger({ username: 'johndoe' }, /* options */)\n} catch (e) {\n// error handling\n}\n}}\n>\nCreate User\n</button>\n)\n}\nIf you want to use the mutation results in rendering, you can get them from the return values of useSWRMutation.\nconst { trigger, data, error } = useSWRMutation('/api/user', sendRequest)\nuseSWRMutation shares a cache store with useSWR, so it can detect and avoid race conditions between useSWR. It also supports mutate's functionalities like optimistic updates and rollback on errors. You can pass these options useSWRMutation and its trigger function.\nconst { trigger } = useSWRMutation('/api/user', updateUser, {\noptimisticData: current => ({ ...current, name: newName })\n})\n\n// or\n\ntrigger(newName, {\noptimisticData: current => ({ ...current, name: newName })\n})","defer-loading-data-until-needed#Defer loading data until needed":"You can also use useSWRMutation for loading data. useSWRMutation never start requesting until trigger is called, so you can defer loading data when you actually need it.\nimport { useState } from 'react'\nimport useSWRMutation from 'swr/mutation'\n\nconst fetcher = url => fetch(url).then(res => res.json())\n\nconst Page = () => {\nconst [show, setShow] = useState(false)\n// data is undefined until trigger is called\nconst { data: user, trigger } = useSWRMutation('/api/user', fetcher);\n\nreturn (\n<div>\n<button onClick={() => {\ntrigger();\nsetShow(true);\n}}>Show User</button>\n{show && user ? <div>{user.name}</div> : null}\n</div>\n);\n}","optimistic-updates#Optimistic Updates":"In many cases, applying local mutations to data is a good way to make changes\nfeel faster — no need to wait for the remote source of data.With the optimisticData option, you can update your local data manually, while\nwaiting for the remote mutation to finish. Composing rollbackOnError you can also\ncontrol when to rollback the data.\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction Profile () {\nconst { mutate } = useSWRConfig()\nconst { data } = useSWR('/api/user', fetcher)\n\nreturn (\n<div>\n<h1>My name is {data.name}.</h1>\n<button onClick={async () => {\nconst newName = data.name.toUpperCase()\nconst user = { ...data, name: newName }\nconst options = {\noptimisticData: user,\nrollbackOnError(error) {\n// If it's timeout abort error, don't rollback\nreturn error.name !== 'AbortError'\n},\n}\n\n// updates the local data immediately\n// send a request to update the data\n// triggers a revalidation (refetch) to make sure our local data is correct\nmutate('/api/user', updateFn(user), options);\n}}>Uppercase my name!</button>\n</div>\n)\n}\n\nThe updateFn should be a promise or asynchronous function to handle the remote mutation, it should return updated data.\nYou can also pass a function to optimisticData to make it depending on the current data:\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction Profile () {\nconst { mutate } = useSWRConfig()\nconst { data } = useSWR('/api/user', fetcher)\n\nreturn (\n<div>\n<h1>My name is {data.name}.</h1>\n<button onClick={async () => {\nconst newName = data.name.toUpperCase()\nmutate('/api/user', updateUserName(newName), {\noptimisticData: user => ({ ...user, name: newName }),\nrollbackOnError: true\n});\n}}>Uppercase my name!</button>\n</div>\n)\n}\nYou can also create the same thing with useSWRMutation and trigger:\nimport useSWRMutation from 'swr/mutation'\n\nfunction Profile () {\nconst { trigger } = useSWRMutation('/api/user', updateUserName)\n\nreturn (\n<div>\n<h1>My name is {data.name}.</h1>\n<button onClick={async () => {\nconst newName = data.name.toUpperCase()\n\ntrigger(newName, {\noptimisticData: user => ({ ...user, name: newName }),\nrollbackOnError: true\n})\n}}>Uppercase my name!</button>\n</div>\n)\n}","rollback-on-errors#Rollback on Errors":"When you have optimisticData set, it’s possible that the optimistic data gets\ndisplayed to the user, but the remote mutation fails. In this case, you can leverage\nrollbackOnError to revert the local cache to the previous state, to make sure\nthe user is seeing the correct data.","update-cache-after-mutation#Update Cache After Mutation":"Sometimes, the remote mutation request directly returns the updated data, so there is no need to do an extra fetch to load it.\nYou can enable the populateCache option to update the cache for useSWR with the response of the mutation:\nconst updateTodo = () => fetch('/api/todos/1', {\nmethod: 'PATCH',\nbody: JSON.stringify({ completed: true })\n})\n\nmutate('/api/todos', updateTodo, {\npopulateCache: (updatedTodo, todos) => {\n// filter the list, and return it with the updated item\nconst filteredTodos = todos.filter(todo => todo.id !== '1')\nreturn [...filteredTodos, updatedTodo]\n},\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\nrevalidate: false\n})\nOr with the useSWRMutation hook:\nuseSWRMutation('/api/todos', updateTodo, {\npopulateCache: (updatedTodo, todos) => {\n// filter the list, and return it with the updated item\nconst filteredTodos = todos.filter(todo => todo.id !== '1')\nreturn [...filteredTodos, updatedTodo]\n},\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\nrevalidate: false\n})\nWhen combined with optimisticData and rollbackOnError, you’ll get a perfect optimistic UI experience.","avoid-race-conditions#Avoid Race Conditions":"Both mutate and useSWRMutation can avoid race conditions between useSWR. For example,\nfunction Profile() {\nconst { data } = useSWR('/api/user', getUser, { revalidateInterval: 3000 })\nconst { trigger } = useSWRMutation('/api/user', updateUser)\n\nreturn <>\n{data ? data.username : null}\n<button onClick={() => trigger()}>Update User</button>\n</>\n}\nThe normal useSWR hook might refresh its data any time due to focus, polling, or other conditions. This way the displayed username\ncan be as fresh as possible. However, since we have a mutation there that can happen at the nearly same time of a refetch of useSWR, there\ncould be a race condition that getUser request starts earlier, but takes longer than updateUser.Luckily, useSWRMutation handles this for you automatically. After the mutation, it will tell useSWR to ditch the ongoing request and revalidate,\nso the stale data will never be displayed.","mutate-based-on-current-data#Mutate Based on Current Data":"Sometimes, you want to update a part of your data based on the current data.With mutate, you can pass an async function which will receive the current cached value, if any, and returns an updated document.\nmutate('/api/todos', async todos => {\n// let's update the todo with ID `1` to be completed,\n// this API returns the updated data\nconst updatedTodo = await fetch('/api/todos/1', {\nmethod: 'PATCH',\nbody: JSON.stringify({ completed: true })\n})\n\n// filter the list, and return it with the updated item\nconst filteredTodos = todos.filter(todo => todo.id !== '1')\nreturn [...filteredTodos, updatedTodo]\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\n}, { revalidate: false })","mutate-multiple-items#Mutate Multiple Items":"The global mutate API accepts a filter function, which accepts key as the argument and returns which keys to revalidate. The filter function is applied to all the existing cache keys:\nimport { mutate } from 'swr'\n// Or from the hook if you customized the cache provider:\n// { mutate } = useSWRConfig()\n\nmutate(\nkey => typeof key === 'string' && key.startsWith('/api/item?id='),\nundefined,\n{ revalidate: true }\n)\nThis also works with any key type like an array. The mutation matches all keys, of which the first element is 'item'.\nuseSWR(['item', 123], ...)\nuseSWR(['item', 124], ...)\nuseSWR(['item', 125], ...)\n\nmutate(\nkey => Array.isArray(key) && key[0] === 'item',\nundefined,\n{ revalidate: false }\n)\nThe filter function is applied to all existing cache keys, so you should not assume the shape of keys when using multiple shapes of keys.\n// ✅ matching array key\nmutate((key) => key[0].startsWith('/api'), data)\n// ✅ matching string key\nmutate((key) => typeof key === 'string' && key.startsWith('/api'), data)\n\n// ❌ ERROR: mutate uncertain keys (array or string)\nmutate((key: any) => /\\/api/.test(key.toString()))\nYou can use the filter function to clear all cache data, which is useful when logging out:\nconst clearCache = () => mutate(\n() => true,\nundefined,\n{ revalidate: false }\n)\n\n// ...clear cache on logout\nclearCache()"}},"/docs/error-handling":{"title":"Error Handling","data":{"":"If an error is thrown inside fetcher, it will be returned as error by the hook.\nconst fetcher = url => fetch(url).then(r => r.json())\n\n// ...\nconst { data, error } = useSWR('/api/user', fetcher)\nThe error object will be defined if the fetch promise is rejected.","status-code-and-error-object#Status Code and Error Object":"Sometimes we want an API to return an error object alongside the status code.\nBoth of them are useful for the client.We can customize our fetcher to return more information. If the status code is not 2xx,\nwe consider it an error even if it can be parsed as JSON:\nconst fetcher = async url => {\nconst res = await fetch(url)\n\n// If the status code is not in the range 200-299,\n// we still try to parse and throw it.\nif (!res.ok) {\nconst error = new Error('An error occurred while fetching the data.')\n// Attach extra info to the error object.\nerror.info = await res.json()\nerror.status = res.status\nthrow error\n}\n\nreturn res.json()\n}\n\n// ...\nconst { data, error } = useSWR('/api/user', fetcher)\n// error.info === {\n//   message: \"You are not authorized to access this resource.\",\n//   documentation_url: \"...\"\n// }\n// error.status === 403\n\nNote that data and error can exist at the same time. So the UI can display the existing data,\nwhile knowing the upcoming request has failed.\nHere we have an example.","error-retry#Error Retry":"BackendGuide uses the exponential backoff algorithm to retry the request on error.\nThe algorithm allows the app to recover from errors quickly, but not waste resources retrying too often.You can also override this behavior via the onErrorRetry option:\nuseSWR('/api/user', fetcher, {\nonErrorRetry: (error, key, config, revalidate, { retryCount }) => {\n// Never retry on 404.\nif (error.status === 404) return\n\n// Never retry for a specific key.\nif (key === '/api/user') return\n\n// Only retry up to 10 times.\nif (retryCount >= 10) return\n\n// Retry after 5 seconds.\nsetTimeout(() => revalidate({ retryCount }), 5000)\n}\n})\nThis callback gives you the flexibility to retry based on various conditions. You can also disable it by setting shouldRetryOnError: false.It's also possible to provide it via the Global Configuration context.","global-error-report#Global Error Report":"You can always get the error object inside the component reactively.\nBut in case you want to handle the error globally, to notify the UI to show a toast or a snackbar, or report it somewhere such as Sentry,\nthere's an onError event:\n<SWRConfig value={{\nonError: (error, key) => {\nif (error.status !== 403 && error.status !== 404) {\n// We can send the error to Sentry,\n// or show a notification UI.\n}\n}\n}}>\n<MyApp />\n</SWRConfig>"}},"/examples/auth":{"title":"Authentication","data":{"":""}},"/blog/swr-v1":{"title":"Announcing BackendHandbook 1.0","data":{"":"Almost 2 years ago we open sourced BackendHandbook, the tiny data-fetching React library that people love. Today we are reaching another milestone: the 1.0 version of BackendHandbook!","whats-new#What’s New":"","smaller-size#Smaller Size":"Performance is one of the most important features of BackendHandbook. In 1.0, we made the library significantly smaller without removing any existing features:\n41% smaller core (24% smaller when gzipped, 3.9 kB)\n52% smaller package install size\nImproved tree-shaking\n\nThere are many reasons to make the library lightweight: your application will have a smaller bundle, a leaner runtime, and a smaller node_modules directory.We’ve also improved the bundling of the package, and it now supports path imports:\nimport useSWR from 'swr'\nimport useSWRInfinite from 'swr/infinite'\nIf you are not using useSWRInfinite, it will not be included in your application.","fallback-data#Fallback Data":"In 1.0, there’s a new fallback option that you can provide any pre-fetched data as the initial value of all BackendHandbook hooks with specific keys:\n<SWRConfig value={{\nfallback: {\n'/api/user': { name: 'Bob', ... },\n'/api/items': ...,\n...\n}\n}}>\n<App/>\n</SWRConfig>\nThis is very helpful for scenarios such as SSG, SSR, and data mockup for testing. Check the docs Next.js SSG and SSR for more details.For better consistency and to avoid confusion, the old initialData is now renamed to fallbackData, which still provides a single fallback value for the given hook.","immutable-mode#Immutable Mode":"Sometimes you want to mark a resource as immutable if it will never change. It's better to disable automatic revalidations for it and only make the request once. There is now a helper hook to make this easier:\nimport useSWRImmutable from 'swr/immutable'\n\n// ...\n\nuseSWRImmutable(key, fetcher, options)\nIt has the exact same API as the useSWR hook, but it will never revalidate upon tab focus or network recovery. There's also a new option, revalidateIfStale, you can use to control the behavior precisely. More information can be found here.","custom-cache-provider#Custom Cache Provider":"By default, BackendHandbook uses a single global cache to store all the data. In 1.0, you are able to customize it with the new provider option:\n<SWRConfig value={{\nprovider: () => myCache\n}}>\n<App/>\n</SWRConfig>\nYou can use this new feature to do many powerful things. We have a couple of examples here: Mutate Multiple Keys with RegEx, LocalStorage Based Persistent Cache, Reset Cache Between Tests.This new cache provider API is also more compatible with concurrent rendering of React 18. If you are adding a cache provider, make sure to use the global mutate function returned from useSWRConfig().You can read the docs Cache Provider for more details.","useswrconfig#useSWRConfig()":"There is a new Hook API to return all global configurations, including the current cache provider and global mutate function:\nimport { useSWRConfig } from 'swr'\n\nfunction Foo () {\nconst { refreshInterval, cache, mutate, ...restConfig } = useSWRConfig()\n\n// ...\n}\nMore information can be found here.","middleware#Middleware":"BackendHandbook Middleware provide a new way for you to build and reuse abstractions on top of BackendHandbook hooks:\n<SWRConfig value={{ use: [...middleware] }}>\n\n// ... or directly in `useSWR`:\nuseSWR(key, fetcher, { use: [...middleware] })\nA lot of new ideas can be implemented with this feature, and we've built some examples: Request Logger, Keep Previous Data When Changing the Key, and Serialize Object Keys.Check the Middleware API for more details.","improvements-and-better-test-coverage#Improvements and Better Test Coverage":"Since 0.x, we've made hundreds of small improvements and bugfixes. BackendHandbook now has 157 tests that cover most of the edge cases in data fetching. Read the Changelog for more details.","docs-translations#Docs Translations":"Thanks to our contributors and Nextra’s i18n feature, we now offer BackendHandbook documentation in six different languages:\nEnglish\nSpanish\nSimplified Chinese\nJapanese\nKorean\nRussian","migration-guide#Migration Guide":"","update-useswrinfinite-imports#Update useSWRInfinite Imports":"useSWRInfinite needs to be imported from swr/infinite:\n- import { useSWRInfinite } from 'swr'\n+ import useSWRInfinite from 'swr/infinite'\nIf you are using the corresponding types, update the import path too:\n- import { SWRInfiniteConfiguration, SWRInfiniteResponse } from 'swr'\n+ import { SWRInfiniteConfiguration, SWRInfiniteResponse } from 'swr/infinite'","change-revalidate-to-mutate#Change revalidate to mutate":"useSWR no longer returns the revalidate method, change to mutate instead:\n- const { revalidate } = useSWR(key, fetcher, options)\n+ const { mutate } = useSWR(key, fetcher, options)\n\n\n// ...\n\n\n- revalidate()\n+ mutate()","rename-initialdata-to-fallbackdata#Rename initialData to fallbackData":"- useSWR(key, fetcher, { initialData: ... })\n+ useSWR(key, fetcher, { fallbackData: ... })","no-more-default-fetcher#No More Default Fetcher":"BackendHandbook no longer provides the default fetcher (a fetch call that parses the data as JSON). The easiest way to migrate the change is to use the <SWRConfig> component:\n<SWRConfig value={{ fetcher: (url) => fetch(url).then(res => res.json()) }}>\n<App/>\n</SWRConfig>\n\n// ... or\nuseSWR(key, (url) => fetch(url).then(res => res.json()))","recommend-to-use-the-hook-returned-mutate#Recommend to Use the Hook-Returned mutate":"This is not a breaking change, but we will now recommend to always use the mutate returned from the useSWRConfig hook:\n- import { mutate } from 'swr'\n+ import { useSWRConfig } from 'swr'\n\n\nfunction Foo () {\n+   const { mutate } = useSWRConfig()\n\nreturn <button onClick={() => mutate('key')}>\nMutate Key\n</button>\n}\nIf you are not using a cache provider, the current global import import { mutate } from 'swr' still works.","renamed-types#Renamed Types":"If you are using TypeScript, the following type names have been changed for consistency:\n0.x (deprecated)\t1.0\tNote\tConfigInterface\tSWRConfiguration\t\tkeyInterface\tKey\t\tresponseInterface\tSWRResponse\t\tRevalidateOptionInterface\tRevalidatorOptions\t\trevalidateType\tRevalidator\t\tSWRInfiniteResponseInterface\tSWRInfiniteResponse\tmoved to swr/infinite\tSWRInfiniteConfigInterface\tSWRInfiniteConfiguration\tmoved to swr/infinite","beta-and-unofficial-feature-users#Beta and Unofficial Feature Users":"If you are using a beta version of BackendHandbook, or using any undocumented APIs, please be aware of the following changes:\nimport { cache } from 'swr' is removed; use the new useSWRConfig API instead.\nimport { createCache } from 'swr' is removed; use the new Cache Provider API instead.\nrevalidateWhenStale is renamed to revalidateIfStale.\nmiddlewares is renamed to use.","changelog#Changelog":"Read the full Changelog on GitHub.","whats-next#What’s Next":"In future releases, we will keep improving the library while maintaining the stability. We are also aiming to embrace future React versions, as several new features and improvements in 1.0 are already preparing for that. In addition, we are also working on new features to improve the experience of doing data fetching in React and the experience of using this library.If you have any feedback about this release, please let us know.","thank-you#Thank You!":"Special thanks to Toru Kobayashi and Yixuan Xu for their contributions to the library, and Paco Coursey, uttk, Tomohiro SHIOYA, Markoz Peña, SeulGi Choi, Fang Lu, Valentin Politov for their work on the translations and docs. This release can't happen without them.We also want to thank the entire community, our 110 contributors (+ 45 docs contributors), and everyone who helped and gave us feedback!"}},"/docs/lets-start":{"title":"Let's start","data":{"":"This guide covers a wide range of server-side technologies and provides hands-on exercises and projects to help you apply your new knowledge. You will learn about industry-standard tools and technologies.Whether you are a beginner or an experienced developer looking to expand your skills, this is the perfect resource to help you boost the art of server-side development.","what-is-backend-development#What is backend development":"Backend development refers to the server-side of web development, which is responsible for managing and processing data, and communicating with the frontend (the client-side of web development) through APIs. Backend developers write code in programming languages such as Python, Java, or NodeJS etc, to create and maintain the server-side logic and functionality of a website or application. They also work with databases to store and retrieve data, and create and implement APIs that allow the frontend to communicate with the backend. Backend development is an essential part of web development as it enables the smooth functioning and data management of a website or application.","reasons-for-becoming-a-backend-developer#Reasons for becoming a backend developer":"There are several reasons why someone may choose to become a backend developer:\nProblem-solving: Backend development involves using logic and programming skills to solve complex problems and create efficient solutions.\nConstant learning: Backend development is a constantly evolving field, with new technologies and languages being developed. This allows backend developers to continuously learn and improve their skills.\nHigh demand: Backend developers are in high demand, as the need for efficient and secure data management and processing is crucial for almost any industry.\nCareer growth: Backend development can lead to many career opportunities, from entry-level developer positions to senior management roles.\nGood salary: Backend developers tend to earn a good salary, as the role is highly technical and requires a high level of skill and expertise.\nMaking a difference: Backend development enables people to create and maintain the infrastructure of websites and applications that are used by millions of people every day, making a real difference in people's lives.","challenges-and-rewards#Challenges and Rewards":"As with any career, backend development comes with its own set of challenges and rewards.\nDebugging and Troubleshooting: Backend developers often have to debug and troubleshoot issues, which can be time-consuming and frustrating.\nScalability and Performance: Backend developers need to ensure that the server-side of a website or application can handle a large amount of traffic and data, which can be challenging.\nSecurity: Backend developers are responsible for ensuring the security of the data being processed and stored, which requires staying up to date on the latest security threats and implementing best practices.\nKeeping up with new technologies: Backend development is a constantly evolving field, and backend developers need to stay up to date with new technologies and programming languages in order to remain competitive."}},"/docs/internet/how-internet-work":{"title":"How Internet work?","data":{"":"A computer scientist named Tim Berners-Lee was working at a European physics laboratory called CERN. He had the idea to create a system called the World Wide Web, which would make it easier for people to access and share information on the Internet. Using a simple language called HTML, he developed a way for people to create and view web pages, which are documents that can contain text, images, and links to other web pages. He also created the first web browser, called WorldWideWeb the first web browser was the foundation of the modern Internet.","introduction#Introduction":"The Internet is a global network of interconnected devices and servers that communicate with each other using standardized protocols. It allows for the exchange of information and resources, such as sending and receiving emails, accessing websites, and sharing files. The Internet enables communication, education, and commerce on a global scale, and has become an essential tool in modern society.","how-the-internet-connects-users#How the Internet Connects Users":"The internet is a vast network of devices that are all connected to each other, allowing them to share and exchange information. This network is made up of several key components, such as servers, routers, and modems.Servers are like librarians of the internet, they store and manage large amounts of data, making it available to other devices on the internet. Without them, we would not be able to access the websites and information we need.Routers are like traffic controllers, they direct data packets between networks, allowing information to be sent and received between devices on different networks.Modems are like translators, they convert digital data into a form that can be transmitted over a telephone or cable line, allowing devices to connect to the internet. Without modems, we would not be able to access the internet from our homes.But all these components alone are not enough to connect people to the internet. There are also protocols that need to be followed, such as TCP/IP and DNS.TCP/IP is like a set of rules that ensures that data is transmitted accurately and efficiently between devices.DNS is like a phone book of the internet, it translates domain names, such as www.example.com, into IP addresses, making it easy for people to remember and access websites. Without DNS, we would have to remember a string of numbers instead of a website name.Finally, there are Internet Service Providers (ISPs), the companies that provide internet access to users by maintaining and operating the infrastructure that connects devices to the internet. ISPs are like gatekeepers, they allow us to enter the vast network of the internet and access the world of information.And so, with the help of servers, routers, modems, TCP/IP, DNS, and ISPs, people were able to connect to the internet, share information and connect with each other from all over the world. And the internet became an integral part of our daily lives, connecting us in ways we never thought possible.","how-the-internet-transmits-data#How the Internet Transmits Data":"Well, imagine that the data you want to send, such as an email or a picture, is like a package that needs to be delivered. The internet uses a method called packet switching to break this package into small pieces called packets. These packets are then sent out into the internet, like a flock of birds flying in different directions.Each packet has a special label on it, called an IP address, that tells it where it needs to go. This is where the Internet Protocol (IP) comes in. IP makes sure that each packet reaches its destination by routing it through the right networks and to the right device.But what happens if a packet gets lost along the way? That’s where the Transmission Control Protocol (TCP) comes in. TCP is like a postman that checks to make sure that all the packets have arrived safely and if not, it sends them again.Now, packets need a way to travel across the internet, and for that, the internet uses different types of transmission media. Copper wires, Fiber-optic cables, satellites, and wireless are some of the ways packets can travel to their destination.Copper wires are like roads, they are widely used to transmit data over short distances. Fiber-optic cables are like superhighways, they are faster and can transmit data over longer distances. Satellites are like airplanes, they transmit data to remote areas where there are no roads or superhighways. And wireless is like a bird, it uses radio waves to transmit data without the need for cables.And so, with the help of packet switching, IP, TCP, and different types of transmission media, data is able to travel efficiently and reliably across the internet, connecting people and allowing them to share information from all over the world.","security-and-privacy-on-the-internet#Security and Privacy on the Internet":"Back of time the internet was a relatively new and small network used primarily by researchers and academics. But as it began to grow and become more widely adopted, it became clear that security and privacy were major concerns.As more and more people began to use the internet for sensitive activities such as online banking and shopping, it became apparent that there was a need to protect their personal and financial information from hackers and other malicious actors.At the same time, governments and other organizations began to realize that the internet could be used for surveillance and censorship, leading to concerns about privacy and free speech.To address these concerns, security experts and privacy advocates began to develop a range of technologies and techniques to protect internet users. Firewalls, encryption, and virtual private networks (VPNs) were invented to protect against unauthorized access and protect users’ data.As the internet continued to evolve and become more integrated into our lives, the need for security and privacy became even more important. With the growing use of social media and the proliferation of connected devices, it became increasingly easy for hackers and other malicious actors to access personal information and cause harm.As a result, security and privacy have become critical issues that must be considered in the design and use of internet technology. Today, security and privacy experts continue to work to protect internet users from threats and to develop new technologies to improve privacy and security online.The story of security and privacy on the internet is an ongoing one, as technology evolves and new threats emerge, the need to protect ourselves and our information will always be present, but with the right tools and knowledge, we can navigate the internet safely.","summary#Summary":"As the internet continues to evolve, it is important that we remain vigilant and continue to develop new technologies to protect ourselves and our information online."}},"/docs/internet/introduction-to-http":{"title":"Introduction to HTTP","data":{"":"HTTP is a client-server protocol, which means that a client (such as a web browser) sends a request to a server, and the server sends a response back to the client. The request and response are both in the form of a message.","what-is-http#What is HTTP":"HTTP (Hypertext Transfer Protocol) is a protocol used for transferring data over the internet. It is the foundation of the World Wide Web and is used to transfer data between a web browser and a web server.For example, when you type \"www.google.com\" into your web browser, your browser sends a request to the server where the Google website is hosted, using HTTP. The server then responds by sending the Google homepage back to your browser, also using HTTP. This request and response process is done using the HTTP protocol.HTTP is also used for other types of web requests, such as submitting a form, logging in to a website, or downloading a file. For instance, when you fill up a registration form on a website and click on the submit button, your browser sends the data you entered to the server via HTTP. The server then processes the request and sends a response back to your browser, which could be either a success message or an error message.Overall, HTTP plays a crucial role in the functioning of the World Wide Web.","types-of-http-requests#Types of HTTP Requests":"There are several different types of requests that can be made using HTTP, each with its own specific purpose. The four most common types of requests are:\nGET: A GET request is used to retrieve data from a server. When you type a URL into your web browser and press enter, you are sending a GET request to the server to retrieve the webpage at that URL. GET requests are also used to retrieve data from web APIs, such as when a weather app retrieves the current temperature from a weather service.\nPOST: A POST request is used to send data to a server. It is commonly used when submitting a form on a website, such as when you sign up for an account or make a purchase. The data you enter into the form is sent to the server via a POST request.\nPUT: A PUT request is used to update data on a server. For example, you could use a PUT request to update a user's profile information on a website.\nDELETE: A DELETE request is used to delete data from a server. For example, you could use a DELETE request to delete a user's account from a website.\n\nIn addition to these four main types of requests, there are also other types of HTTP requests, such as PATCH and OPTIONS, that are used less frequently but still serve specific purposes. Understanding when to use each type of request is an important part of web development and working with the HTTP protocol.","http-headers-and-messages#HTTP Headers and Messages":"HTTP headers and messages are an important part of the HTTP protocol. They are used to provide additional information about the request or response being sent or received.","understanding-headers#Understanding headers":"HTTP headers are key-value pairs that provide additional information about the request or response being sent or received. They are used to give the server or client more information about the message, such as what type of data is being sent or the status of the response.For example, when a browser sends a GET request to a server to retrieve a webpage, the request includes several headers that provide additional information. One of the headers is the \"Accept\" header, which tells the server what type of data the browser is able to handle, such as HTML, XML, or JSON. Another header is the \"User-Agent\" header, which identifies the type of browser or client that made the request.Another example is when you make a POST request to a server to submit a form, the request includes headers like the \"Content-Type\" header, which tells the server what type of data is being sent in the body of the request, like if it's plain text, HTML or JSON. And the \"Content-Length\" header, tells the server the size of the message body in bytes.Headers can also be used to provide authentication information, such as when a client sends an \"Authorization\" header with a token or a username and password.In summary, headers play an important role in the HTTP protocol by providing additional information about the message being sent or received. They are used to specify the type of data being sent, the status of the response, and other important information that is required for the server or client to correctly process the request.","understanding-message-structure#Understanding message structure":"HTTP messages are the basic unit of communication between a client and a server in the HTTP protocol. They consist of two parts: the headers and the body.\nHeaders: The headers contain information about the message, such as the type of request and the type of data being sent. They are key-value pairs that provide additional information about the message, such as what type of data is being sent, the status of the response, and other important information.\nBody: The body contains the actual data being sent or received. For example, when you make a GET request to a server to retrieve a webpage, the body of the response will contain the HTML code for the webpage. When you submit a form on a website, the data you entered into the form is sent to the server in the body of a POST request.\n\nThe structure of an HTTP message is defined in the HTTP specification and follows a specific format. The headers and body are separated by a blank line, and each header is on its own line, with the key and value separated by a colon.","statelessness-of-http#Statelessness of HTTP":"HTTP is a stateless protocol, which means that the server does not maintain any information about the client between requests. Each request is treated independently, and the server does not remember any previous requests made by the client.For example, when a client sends a GET request to a server to retrieve a webpage, the server sends the webpage back to the client in the form of a response. However, the server does not remember that the client made this request. If the client makes another request to the same server for the same webpage, the server will treat this as a new request and send the webpage back to the client again, without any knowledge of the previous request.","impact-on-web-server-scalability#Impact on web server scalability":"The statelessness of HTTP has a significant impact on web server scalability. Since the server does not maintain any information about the client between requests, it can easily handle multiple requests simultaneously and does not need to allocate resources for maintaining the state. This allows for more efficient use of server resources and makes it easy to scale and distribute web servers.For example, with a stateless protocol like HTTP, it is easy to add more servers to a web server cluster to handle an increase in traffic. Each server can handle requests independently and does not need to communicate with other servers to maintain a state. This makes it possible to handle a large number of concurrent requests and allows for easy scaling.","evolution-of-http#Evolution of HTTP":"HTTP, or Hypertext Transfer Protocol, has gone through several evolutions over the years since its creation in 1991. Initially, the first version of HTTP was very simple and only supported basic functionality such as GET, POST, and HEAD methods.\nHTTP/1.0 was the first official version released in 1996, it added support for additional methods such as PUT and DELETE, and also introduced the concept of HTTP headers.\nHTTP/1.1 was released In 1999, which made several improvements and additions to the protocol, such as support for persistent connections, improved caching, and better handling of request and response headers. This version also introduced the concept of chunked transfer encoding, which allows for the transfer of large files in smaller chunks.\nHTTP/2 was released in 2015, which made several improvements over HTTP/1.1, such as multiplexing, which allows for multiple requests to be sent over the same connection, and server push, which allows the server to send resources to the client without the client requesting them. This version also introduced the use of binary framing, which improves the efficiency of the data transfer.\nHTTP/3 is the latest version of HTTP which is based on QUIC(Quick UDP Internet Connections) protocol, it is still in the experimental phase, but it aims to improve the speed and security of the web by using the User Datagram Protocol (UDP) instead of the Transmission Control Protocol (TCP).\n\nOverall, the evolution of HTTP has brought many improvements and additional features to the protocol, making it more efficient and easier to use. The most recent versions of HTTP have focused on improving the speed and security of the web while keeping backward compatibility with older versions.","differences-between-http-and-https#Differences between HTTP and HTTPS":"HTTP (Hypertext Transfer Protocol) and HTTPS (HTTP Secure) are both protocols used for transferring data over the internet, but there are some key differences between them.The main difference between HTTP and HTTPS is that HTTPS uses a secure SSL/TLS connection to encrypt the data being sent between the client and the server. This means that any data transmitted over HTTPS, such as login credentials or credit card information, is protected from being intercepted and read by unauthorized parties.","read-more#Read More":"What is HTTP?\nAn overview of HTTP\nJourney to HTTP/2\nHTTP/3 From A To Z: Core Concepts\nHTTP/1 to HTTP/2 to HTTP/3"}},"/docs/internet/the-secret-of-browsers-and-how-they-work":{"title":"The secret of browsers and how they work?","data":{"":"Understanding how browsers work can help users make more informed decisions about which browser to use, how to optimize their browsing experience, and how to troubleshoot issues that may arise. Additionally, understanding the inner workings of browsers can also provide insight into the design and development of web applications and websites.","introduction#Introduction":"In the early days of the internet, people used to access websites through a program called a \"terminal.\" These programs were clunky and difficult to use, and they could only display plain text.But as the internet grew, a few clever programmers decided to create a better way to access the web. They built the first web browsers, which were much more user-friendly and could display images and other multimedia as well as text. As the web continued to evolve, so did browsers. They became more sophisticated and more powerful, with new features like tabs, bookmarks, and private browsing. Today, there are many different browsers to choose from, each with its own set of features and capabilities.","browser-components#Browser components":"The browser's main components are:\nUser Interface: The user interface, or UI, is the part of the browser that the user interacts with. It includes the address bar, tabs, and buttons for navigating and controlling the browser.\nRendering engine: The rendering engine is responsible for displaying the content of a web page on the screen. It takes the code of a web page, such as HTML and CSS, and converts it into a visual representation that the user can view. The browser uses the Document Object Model (DOM) to represent the web page in the memory so that javascript can interact and modify the page. Different browsers use different rendering engines, for example, Google Chrome V8, Firefox SpiderMonkey, and Safari JavaScriptCore.\nNetworking layer: The networking layer manages the communication between the browser and the web server. It sends requests for web pages and receives the response, which is then passed to the rendering engine. The browser uses the Hypertext Transfer Protocol (HTTP) to communicate with the web server, and it also implements Transport Layer Security (TLS) to encrypt the communication and provide secure browsing.\nJavaScript interpreter: JavaScript engines are typically implemented as part of a web browser, but they can also be used in other environments such as servers (Node.js), desktop apps, mobile apps, and embedded systems. The JavaScript engine interprets the JavaScript code and converts it into machine code that the computer can understand and execute. JavaScript engines use Just-In-Time (JIT) compilation to improve the performance of JavaScript code. JIT compilation converts JavaScript code into machine code at runtime, which allows for faster execution compared to interpreting the code every time it is run. Different browsers use different JavaScript engines, for example, Google Chrome uses V8, Firefox uses SpiderMonkey and Safari uses JavaScriptCore.\nData storage: Storing data is through HTML5 web storage, which allows websites to store data on the user's device using JavaScript. This can include data such as user preferences and shopping cart contents.","browser-process#Browser process":"The browser process is the sequence of steps that a browser goes through to display a web page on a user's device.\nRequesting a web page: When a user types a URL into the address bar or clicks on a link, the browser sends a request to the web server for the corresponding web page. The browser uses the Hypertext Transfer Protocol (HTTP) to communicate with the web server.\nParsing and rendering: Once the web server sends the response, the browser's rendering engine parses the code of the web page and converts it into a visual representation. The rendering engine may also apply any CSS styles to the page, and the JavaScript engine will execute any JavaScript code. The browser uses the Cascading Style Sheets (CSS) to apply the styles to the page and make it look more visually appealing.\nJavaScript execution: If the web page contains JavaScript code, the browser's JavaScript engine will execute it. This allows for interactive and dynamic web pages. JavaScript code can be used to create dynamic effects on the page, such as animations, and can also be used to perform actions on the page, such as form validation.\nLoading External Resources: The browser process also includes the loading of external resources like images, videos, audio files, fonts and other files that are specified in the HTML and CSS. They are requested and loaded by the browser.\nCaching: After a web page is loaded, the browser will cache some of the resources like images, scripts, and stylesheets, so that they don't have to be downloaded again when the user revisits the page. This can speed up the loading time of the page.\nSecurity checks: Browsers also perform security checks on the web page to ensure that the page is not malicious and that any forms or inputs on the page are secure.\nDisplaying the page: Once the web page is fully loaded and rendered, the browser will display it on the user's device.\n\nThis process can happen quickly and seamlessly, allowing users to navigate the web with ease. However, there can be issues or errors that occur during the process that can lead to a slow or unsuccessful page load, such as a slow internet connection or a problem with the web server.","read-more#Read more:":"Browser engine\nHow Browsers Work: Behind the Scenes of Modern Web Browsers"}},"/docs/internet/dns-and-how-it-works":{"title":"DNS and how it works?","data":{"":"DNS stands for Domain Name System. It's like a phone book for the internet. Just like how a phone book helps you find a person's phone number by their name, DNS helps your computer find a website by its name.\nWhen you type a website name into your computer, like \"google.com,\" your computer sends a message to the DNS asking it where the website is. The DNS looks up the website's address and sends it back to your computer.\nYour computer then uses that address to connect to the website, like making a phone call to a phone number you found in the phone book.\nThink of it like this, you want to find your friend who lives in a big building with many rooms, but you don't know which room is his. So, you ask the security guard (DNS) where your friend's room is, the guard (DNS) tells you the room number and you go to that room to see your friend (website).","dns-query-process#DNS query process":"When you type a website into your computer, your computer sends a message called a \"query\" to a special computer called a DNS server. This is like asking a librarian where a certain book is located.\nThe DNS server then looks up the website's address in a big book called a \"DNS database\". This book has all the addresses of all the websites on the internet. It's like the librarian looking up the book located in the library catalog.\nOnce the DNS server finds the website's address, it sends it back to your computer. This is like the librarian telling you where the book is located. Then your computer can use that address to connect to the website and show it to you, like you going to the shelf and getting the book you asked for.","dns-resolution-process#DNS resolution process":"When your computer sends a query to a DNS server, the server uses a process called \"resolution\" to find the website's address. It's like a treasure hunt!\nThe server starts by checking its own \"local cache,\" which is like a notebook where it keeps track of website addresses it has found before. If the address is in the cache, the server can just give it to your computer right away. That's like finding the treasure in the first spot you look!\nIf the address isn't in the cache, the server has to go on a treasure hunt. It starts by asking other DNS servers if they know the address. These other servers are like friends who might know where the treasure is. If one of them knows, they can tell the server, and the server can give the address to your computer. That's like finding the treasure with your friend's help!\nIf none of the other servers know the address, the server has to keep looking. It might have to ask for even more servers or check other places, like a big book called a \"root server\" that has a list of all the websites on the internet. This is like asking the librarian for help or checking the library catalog.\nEventually, the server will find the website's address and give it to your computer. Then your computer can use that address to connect to the website and show it to you. It's like finding the treasure and getting to keep it!","dns-caching#DNS caching":"DNS caching is like keeping a notebook of the addresses of websites you've looked up before. When the DNS server looks up a website's address, it saves it in its cache, so that the next time someone asks for the same website, the server can just give them the address right away. It's like remembering where you found a treasure, so you can go back to the same spot to find it again!","questions#Questions":"Can you explain the DNS query process in more detail?\nWhen a user types a domain name into their browser, their computer will first check its own cache to see if it has recently looked up the corresponding IP address. If the IP address is found in the cache, the computer will use it to connect to the website.If the IP address is not found in the cache, the computer will then send a query to a DNS server. The query includes the domain name that the user is trying to access. The DNS server will then perform a series of steps to resolve the query and find the corresponding IP address.\n\nHow does DNS caching improve the efficiency of the DNS system?\nDNS caching is like keeping a notebook of the addresses of websites you've looked up before. When the DNS server looks up a website's address, it saves it in its cache, so that the next time someone asks for the same website, the server can just give them the address right away. It's like remembering where you found a treasure, so you can go back to the same spot to find it again!Caching can help make things faster and more efficient because the server doesn't have to go on a treasure hunt every time someone asks for a website's address. It's like if you remember where you put your favorite toy, you don't have to go look for it again, you can just go and play with it."}},"/docs/learn-a-language/rust":{"title":"rust","data":{"":"Rust is designed to be fast, safe, and concurrent. It is an open-source language developed and maintained by the Rust project.","why-choose-rust-for-learning-backend#Why choose rust for learning backend":"Rust is a good choice for learning backend development because it is a modern, low-level programming language that is designed for performance, safety, and concurrency. It has a strong type system and a focus on memory safety, which helps prevent common programming errors such as null pointer exceptions and buffer overflows. Additionally, Rust has a growing and supportive community and is being used in production by companies such as Dropbox, Mozilla, and Amazon Web Services."}},"/docs/learn-a-language":{"title":"Learn a Language","data":{"":"There are several popular programming languages that can be used for backend development, and each has its own set of advantages and disadvantages. Here is a brief comparison of some commonly used languages:\nJavaScript (Node.js): JavaScript is a popular choice for backend development because it is easy to learn, has a large developer community, and supports both synchronous and asynchronous programming. Node.js, which is built on JavaScript, allows for building scalable network applications.\nPython: Python is a versatile language that is often used for scientific computing, data analysis, and machine learning. It has a large developer community and a wealth of available libraries and frameworks, such as Django and Flask.\nRuby (Ruby on Rails): Ruby is a popular choice for web development because of its elegance and readability. The Ruby on Rails framework, often simply called Rails, provides a structure for building web applications.\nJava (Spring): Java is a popular choice for enterprise-level backend development. The Spring framework provides a comprehensive set of tools for building Java-based web applications.\nC# (ASP.NET): C# is a popular choice for Windows-based development and has a large developer community. The ASP.NET framework provides a structure for building web applications using C#.\nGo: Go is a statically typed, compiled language that is designed for building high-performance network services. Go is also known for its simplicity, fast compilation times, and built-in support for concurrency.\nPHP (Laravel): PHP is widely used for web development and has a large developer community. The Laravel framework provides a structure for building web applications using PHP.\n\nIt's important to note that these are just a few examples of the many languages that can be used for backend development, and the choice of language often depends on the specific requirements of the project and personal preferences."}},"/docs/git/version-control-systems":{"title":"Version Control Systems","data":{"":"So imagine you have a big notebook, and you want to share it with your friends. But, sometimes you make mistakes and draw something you don't like. With a notebook, you can't go back and erase just that one thing, you have to start a new notebook.A Version Control System is like a special notebook that keeps track of all the changes you make, so you can go back and look at them later. And, if you make a mistake, you can go back to an earlier version and start again from there. It's kind of like using the \"undo\" button on a computer.It's also a way for multiple people to work on the same notebook at the same time, and it will keep track of who made what changes and when. That way, if two people draw on the same page at the same time, the Version Control System will figure out how to put the drawings together without making a mess.s","repo-hosting-services#Repo Hosting Services":"Okay, so you know how you share your notebook with your friends? Well, a Repo Hosting Service is like a big cabinet where you can put your notebook, and it will keep it safe and make it easy for your friends to find.It's a place where you can store your notebook on the internet so that other people can access it from anywhere, even if they're not next to you. It's like a big library where you can put your notebook on a shelf and people can come and look at it or even borrow it to make their own copies.And, just like a library, there are many different Repo Hosting Services, and each one has its own set of rules and ways of doing things. Some are free, and others cost money. Some are for big groups, and others are for just a few friends.It's a good way to share your notebook with people all around the world and work on it together.","git#Git":"Git is like a magic tool that helps you use a Version Control System. It's kind of like a special pen that you use to write in your notebook.With it, you can tell your computer to take a picture of your notebook, so you can save it and go back to it later. You can also tell git to show you the differences between different pictures of your notebook, so you can see what has changed.It also helps you share your notebook with your friends, by sending and receiving pictures of your notebook, so you can all work on the same notebook together. Git helps you keep your notebook organized and make sure you don't lose any of your work.Just like a pen, it is a tool that helps you write, save and share your work, in this case, it's the code.","start-git#Start Git":"To start using git, you first need to install it on your computer. You can download the appropriate version for your operating system from the official git website.Once git is installed, you can use it in the command line to interact with your repository. The first step is to initialize a new repository. This can be done by navigating to the directory that you want to turn into a repository and running the command \"git init\".After that, you can start adding files to the repository by using the command \"git add\" followed by the file name, or you can use \"git add .\" to add all files in the current directory. You also need to commit the changes you made with the command \"git commit -m \"message\"\", where message is a short description of the changes you made.You can also connect your local repository to a remote repository like GitHub, GitLab or Bitbucket. This allows you to share your code with others, collaborate on projects and keep your local repository in sync with the remote repository.It's important to note that git is a complex tool and these are just the basic commands to get started, there's a lot more to learn and explore about git, but with these commands you should be able to start version controlling your code."}},"/docs/version-control-systems":{"title":"Version Control Systems","data":{"":"So imagine you have a big notebook, and you want to share it with your friends. But, sometimes you make mistakes and draw something you don't like. With a notebook, you can't go back and erase just that one thing, you have to start a new notebook.\nA Version Control System is like a special notebook that keeps track of all the changes you make, so you can go back and look at them later. And, if you make a mistake, you can go back to an earlier version and start again from there. It's kind of like using the \"undo\" button on a computer.\nIt's also a way for multiple people to work on the same notebook at the same time, and it will keep track of who made what changes and when. That way, if two people draw on the same page at the same time, the Version Control System will figure out how to put the drawings together without making a mess.s","repo-hosting-services#Repo Hosting Services":"Okay, so you know how you share your notebook with your friends? Well, a Repo Hosting Service is like a big cabinet where you can put your notebook, and it will keep it safe and make it easy for your friends to find.\nIt's a place where you can store your notebook on the internet so that other people can access it from anywhere, even if they're not next to you. It's like a big library where you can put your notebook on a shelf and people can come and look at it or even borrow it to make their own copies.\nAnd, just like a library, there are many different Repo Hosting Services, and each one has its own set of rules and ways of doing things. Some are free, and others cost money. Some are for big groups, and others are for just a few friends.\nIt's a good way to share your notebook with people all around the world and work on it together.","git#Git":"Git is like a magic tool that helps you use a Version Control System. It's kind of like a special pen that you use to write in your notebook.\nWith it, you can tell your computer to take a picture of your notebook, so you can save it and go back to it later. You can also tell git to show you the differences between different pictures of your notebook, so you can see what has changed.\nIt also helps you share your notebook with your friends, by sending and receiving pictures of your notebook, so you can all work on the same notebook together. Git helps you keep your notebook organized and make sure you don't lose any of your work.\nJust like a pen, it is a tool that helps you write, save and share your work, in this case, it's the code.","start-git#Start Git":"To start using git, you first need to install it on your computer. You can download the appropriate version for your operating system from the official git website.\nOnce it is installed, you can use it in the command line to interact with your repository. The first step is to initialize a new repository. This can be done by navigating to the directory that you want to turn into a repository and running the command \"git init\".\nAfter that, you can start adding files to the repository by using the command \"git add\" followed by the file name, or you can use \"git add .\" to add all files in the current directory. You also need to commit the changes you made with the command \"git commit -m \"message\", where the message is a short description of the changes you made.\nYou can also connect your local repository to a remote repository like GitHub, GitLab or Bitbucket. This allows you to share your code with others, collaborate on projects and keep your local repository in sync with the remote repository.\nIt's important to note that it is a complex tool and these are just the basic commands to get started, there's a lot more to learn and explore about it, but with these commands, you should be able to start version controlling your code.","questions#Questions":"What is a Version Control System, and why is it important?\nA Version Control System (VCS) is a software tool that manages and keeps track of the changes made to files over time. It records the history of changes and allows users to revert to earlier versions of the files if needed.\n\nCan you explain the difference between git and a Repo Hosting Service?\nVCS tool that allows you to track and manage changes to files, while a Repo Hosting Service provides a platform to store and share those changes with others. Git provides the version control functionality and the Repo Hosting Service provides a place to store the codebase online, making it easily accessible to multiple users."}},"/docs/os-and-general-knowledge":{"title":"OS and General Knowledge","data":{"":"","terminal-usage#Terminal usage":"The terminal is a command-line interface (CLI) that allows users to interact with the operating system by typing commands. It is also known as a shell or command prompt. These commands allow you to perform various tasks such as creating and deleting files and directories, running programs, and managing system settings.Some commonly used commands include:\nls : lists the files and directories in the current directory\ncd : changes the current directory\nmkdir : creates a new directory\ntouch : creates a new file\nmv : moves or renames a file or directory\nrm : deletes a file or directory\ncp : copies a file or directory\n\nTo open the terminal on a Windows or Mac, you can use the search bar to look for \"terminal\" or \"command prompt\" and then click on the appropriate application. On Linux, it will depend on the flavor you are using, but usually you can press ctrl+alt+t or just search for terminal.The terminal can be a powerful tool for advanced users, but it can also be dangerous if used improperly. It's important to be careful when using commands, especially those that delete or modify files.","posix#POSIX":"POSIX (Portable Operating System Interface) is a set of standards that define how software should interact with the operating system. It was developed by the IEEE (Institute of Electrical and Electronics Engineers) to ensure that software written for one operating system, such as Linux or Mac, can be easily ported to another operating system, such as Windows.POSIX defines several categories of standards, including:\nSystem interfaces: These include system calls, file I/O, and process management. They provide a common way for software to interact with the operating system's kernel.\nShell and utilities: These include the command-line interface (CLI) and common utilities such as ls, cd, and mkdir. They provide a consistent way to perform common tasks across different operating systems.\nC Language Extension: This standard defines how the C programming language should be used to interact with POSIX-compliant operating systems."}},"/docs/os-and-general-knowledge/os-and-general-knowledge":{"title":"OS and General Knowledge","data":{"":"","terminal-usage#Terminal usage":"The terminal is a command-line interface (CLI) that allows users to interact with the operating system by typing commands. It is also known as a shell or command prompt. These commands allow you to perform various tasks such as creating and deleting files and directories, running programs, and managing system settings.Some commonly used commands include:\nls : lists the files and directories in the current directory\ncd : changes the current directory\nmkdir : creates a new directory\ntouch : creates a new file\nmv : moves or renames a file or directory\nrm : deletes a file or directory\ncp : copies a file or directory\n\nTo open the terminal on a Windows or Mac, you can use the search bar to look for \"terminal\" or \"command prompt\" and then click on the appropriate application. On Linux, it will depend on the flavor you are using, but usually you can press ctrl+alt+t or just search for terminal.The terminal can be a powerful tool for advanced users, but it can also be dangerous if used improperly. It's important to be careful when using commands, especially those that delete or modify files.","posix#POSIX":"POSIX (Portable Operating System Interface) is a set of standards that define how software should interact with the operating system. It was developed by the IEEE (Institute of Electrical and Electronics Engineers) to ensure that software written for one operating system, such as Linux or Mac, can be easily ported to another operating system, such as Windows.POSIX defines several categories of standards, including:\nSystem interfaces: These include system calls, file I/O, and process management. They provide a common way for software to interact with the operating system's kernel.\nShell and utilities: These include the command-line interface (CLI) and common utilities such as ls, cd, and mkdir. They provide a consistent way to perform common tasks across different operating systems.\nC Language Extension: This standard defines how the C programming language should be used to interact with POSIX-compliant operating systems."}},"/docs/os-and-general-knowledge/terminal-usage":{"title":"Terminal usage","data":{"":"The terminal is a command-line interface (CLI) that allows users to interact with the operating system by typing commands. It is also known as a shell or command prompt. These commands allow you to perform various tasks such as creating and deleting files and directories, running programs, and managing system settings.\nSome commonly used commands include:\nls : lists the files and directories in the current directory\ncd : changes the current directory\nmkdir : creates a new directory\ntouch : creates a new file\nmv : moves or renames a file or directory\nrm : deletes a file or directory\ncp : copies a file or directory\n\nTo open the terminal on a Windows or Mac, you can use the search bar to look for \"terminal\" or \"command prompt\" and then click on the appropriate application. On Linux, it will depend on the flavor you are using, but usually you can press ctrl+alt+t or just search for terminal.\nThe terminal can be a powerful tool for advanced users, but it can also be dangerous if used improperly. It's important to be careful when using commands, especially those that delete or modify files.","basic-terminal-commands#Basic Terminal Commands":"Here are some basic explanations for the terminal commands you listed:\ngrep : searches for a specified pattern in a file or a stream of text.\nawk : a text processing tool that can be used to perform operations on structured data, such as text files. It is often used to extract data from log files or CSV files.\nsed : a stream editor that can be used to perform basic text transformations on an input stream (a file or input from a pipeline). It is often used to perform search and replace operations on a file or stream of text.\nlsof : stands for \"list open files\". It can be used to display information about files that are open by processes running on the system.\ncurl : a command-line tool for transferring data with URL syntax. It can be used to download files from the internet or to send HTTP requests to web servers.\nwget : a command-line utility for downloading files from the internet. It can be used to download files from a URL or to mirror a website.\ntail : prints the last 10 lines of a file by default, but you can specify a different number of lines. It's often used to view the last few lines of a log file.\nhead : prints the first 10 lines of a file by default, but you can specify a different number of lines. It's often used to view the first few lines of a file.\nless : a command-line utility for viewing text files. It allows you to scroll through the file and search for text.\nfind : a command-line utility that can be used to search for files on the file system. It can search for files based on various criteria, such as name, size, and date modified.\nssh : stands for \"secure shell\". It is a protocol for securely connecting to a remote server and running commands on it.\nkill : sends a signal to a process to terminate it. It can be used to stop a running program or to force a program to exit if it is not responding.\ndig : stands for \"domain information groper\". It is a command-line tool for querying DNS servers. It can be used to look up IP addresses, MX records, and other DNS information.\nThese commands are just a small sample of the many commands available in the terminal, and each of them have many options and switches, but these are the basic usage for each one.","questions#Questions":"Can you explain the difference between relative and absolute paths in the terminal?\nAn absolute path is a path that starts from the root directory (/) and includes all the directories and subdirectories required to reach a specific file or directory. An absolute path will always point to the same location, regardless of the current working directory. For example, /home/user/Documents/file.txt is an absolute path.A relative path, on the other hand, is a path that is relative to the current working directory. A relative path does not include the root directory and only includes the directories and subdirectories required to reach a specific file or directory from the current working directory. For example, if the current working directory is /home/user/Documents, then Documents/file.txt is a relative path."}},"/docs/os-and-general-knowledge/how-os-works":{"title":"How OS works","data":{"":"An operating system (OS) is a software program that manages and controls the hardware and software resources of a computer. It acts as an intermediary between the computer's hardware and the programs that run on it, providing a consistent environment for applications to run in regardless of the specific hardware being used.","memory-management#Memory Management":"Imagine your computer is a big toy box and all the games and programs you use are like the toys inside it.\nThe operating system (OS), which is like the toy box's boss, needs to make sure that all the toys have enough space to play and don't step on each other's toes.\nTo do this, the OS uses something called memory, which is like the toy box's shelves. The shelves have a limited amount of space, so the OS needs to make sure that it's using the space in the best way possible.\nIt also needs to make sure that when you're done playing with a toy, it puts it back on the shelf so that other toys can use the space.\nThat's what memory management does, it makes sure that there's enough space for all the programs and games you're using, and that they don't step on each other's toes.","interprocess-communication#Interprocess Communication":"Sometimes, different programs that are running on your computer want to talk to each other. They want to share information or work together to do something.\nJust like when you and your friends want to play a game together, you have to talk to each other and share the rules or the things you need to play.\nThe way that programs talk to each other is called Interprocess Communication (IPC). The computer's boss, the Operating System (OS), makes sure that all the programs can talk to each other easily and safely.\nIt's like when you want to play a game with your friends in the park, you have to find a way to talk to them, maybe you call them on the phone or send them a message, the same thing happens with the programs, they have to find a way to talk to each other, and the OS makes sure that way is safe and easy.\nThere are different ways that programs can talk to each other using IPC, such as using shared memory, message passing, and pipes. These are like different ways of communicating, like using a phone, a letter or a chat to talk to your friends.\nFor example, let's say you want to add a picture to your document. The word processor program sends a message to the file manager program, asking it to open a dialog box that allows you to select a picture from your computer's hard drive. The file manager program receives the message and opens the dialog box. You then select the picture you want to add, and the file manager program sends a message back to the word processor program with the location of the picture file on the hard drive. The word processor program receives the message and inserts the picture into the document.\nThis is an example of interprocess communication happening between two programs: the word processor and the file manager.","io-management#I/O Management":"When you play on your computer, you use different things to talk to it, like the keyboard to type and the mouse to click. These things are called Input/Output devices, or I/O devices for short.\nThe computer's boss, the Operating System (OS), has to make sure that all the different I/O devices work together nicely, so you can use them to play your games, watch videos and do other things on your computer.\nIt's like when you want to play a game that needs a controller and a microphone, the OS makes sure that the controller is connected and working properly, and also that the microphone is on and you can hear your friends.\nThe OS also manages the data that goes in and out of the computer, like when you're saving a game or watching a video. It makes sure that the data gets to the right place and is stored safely, just like when you want to save your game progress, the OS makes sure that it's saved in the right place so you can come back to it later.\nI/O management also makes sure that the computer can handle multiple I/O operations at the same time, like when you're watching a video and playing a game at the same time, the OS makes sure that the video keeps playing and the game keeps working without interruption.\nIt's like when you're playing a game and listening to music at the same time, the OS makes sure that the music doesn't stop and the game keeps working.\nIn summary, Input/Output management makes sure that all the different Input/Output devices on your computer work together nicely, and that the data coming in and out of the computer is handled efficiently and safely, so you can use your computer to play games, watch videos, and do other fun things.","networking-concepts#Networking Concepts":"Networking is like when you talk to your friends on the phone or send messages to them. Computers can also talk to each other and send messages, and this is called networking. The computer's boss, the Operating System (OS), makes sure that all the different computers can talk to each other and share information. It's like when you have a lot of friends and you want them all to talk to each other, the OS makes sure that everyone can talk to everyone else, and that the messages get to the right person. Computers talk to each other using special codes, called IP addresses. These codes are like phone numbers, but for computers. Just like how you know your friend's phone number to call them, a computer knows the IP address of the computer it wants to talk to. The computers can also be connected together to form a network, like a group of friends that are always talking to each other. This is called a Local Area Network (LAN), it's like a group of friends that always hang out together. Computers can also talk to each other from far away, like when you call your grandparents who live in another state. This is called a Wide Area Network (WAN), it's like a group of friends that live in different places but still talk to each other. Networks can also be connected to the internet, which is like a giant network that connects all the computers in the world together. This allows you to talk to your friends who live in different countries, just like how you can call or message your friends who live in different countries. So, Networking is like talking to your friends on the phone, but for computers. The Operating System makes sure that all the computers can talk to each other, share information, and be connected to a network.","threads-and-concurrency#Threads and Concurrency":"When you're playing a game, sometimes there are many things happening at the same time. Like when you're driving a car, steering, checking the mirror, honking, and also listening to music. All of these things are happening at the same time. Computers can also do many things at the same time. They can play a game, download a video, and print a document all at the same time. This is called concurrency. The computer's boss, the Operating System (OS), makes sure that all the different things that the computer is doing at the same time are organized and working properly. To do this, the OS uses something called threads. Threads are like helpers that the OS sends out to do different things. Just like how you have helpers at home to do different tasks. When you're playing a game, the OS sends out one thread to handle the game's graphics and another thread to play the sound effects. This way, the game can run smoothly and you can enjoy playing it. Threads help the computer to do many things at the same time, like how you can do your homework and listen to music at the same time.\nConcurrency is the ability of a computer to do many things at the same time and Threads are helpers that the OS sends out to do different tasks to achieve concurrency.","process-management#Process Management":"When you're playing on your computer, you might open different games or programs to play with. Each game or program is like a special task that the computer does for you. The computer's boss, the Operating System (OS), has to make sure that all the different tasks are organized and working properly. It does this using something called Process Management. A process is like a recipe for a special task that the computer has to do, and the OS is the chef that makes sure that the recipe is followed correctly and that all the ingredients are ready when they are needed.\nWhen you open a new game or program, the OS creates a new process for it and assigns it the resources it needs to run, like memory and processing power.\nJust like how you have a schedule for the day, and you have to plan what you're going to do and when the OS also has a schedule for the processes, it makes sure that they are running in the right order and that they have enough resources to work properly.","questions#Questions":"What is the role of the OS in managing the computer's memory?\nThe OS is responsible for managing the computer's memory, allocating and deallocating memory to different programs as needed.\n\nWhat is Interprocess Communication (IPC)?\nInterprocess Communication (IPC) is the way that programs talk to each other and share information or work together to do something.\n\nHow does the OS handle Concurrency?\nThe OS uses something called threads, which are like helpers that the OS sends out to do different things, to handle concurrency."}},"/docs/relational-databases/understand-the-basic-concepts":{"title":"Understand Concepts","data":{"":"A relational database is like a big library for storing information. Think of it like a set of bookshelves, where each bookshelf is called a \"table\". Each table has many books, and each book is called a \"row\". Each book has many pages, and each page is called a \"column\". Each book has a special name, like \"Harry Potter\" or \"The Hobbit\", and this special name is called a \"key\". Some books go together, like a cookbook and a recipe book, and these are called \"relationships\". Just like you can find a book quickly by looking for the book's name, a computer can find information quickly in a relational database by looking for the key.For example, in a restaurant, the menu items are the books and each item has its own unique name, that is the key and the ingredients of each item can be considered as the pages of the book.","sql-structured-query-language#SQL (Structured Query Language)":"SQL (Structured Query Language) is like a special language that you can use to talk to a relational database. It's like when you want to ask the librarian for a book, you need to know the name of the book, and you have to ask in a certain way so the librarian can understand you.\nSELECT is like asking the librarian for a book, you tell the computer which book you want by writing the name of the table and the columns you want to see.\nINSERT is like giving the librarian a new book to put on the shelf, you tell the computer the name of the table and the information you want to add.\nUPDATE is like asking the librarian to change something about a book, you tell the computer the name of the table, the name of the book you want to change, and the new information you want to add.\nDELETE is like asking the librarian to take a book off the shelf, you tell the computer the name of the table and the name of the book you want to remove.\n\nIt is important to learn the basics of SQL statements to interact with relational databases effectively. Just like how you would need to know how to ask for a book in a library in order to find what you are looking for, you need to know how to write SQL statements to retrieve, add, modify and delete data in a relational database.","choose-a-database#Choose a Database":"MySQL: MySQL is an open-source relational database management system that is widely used and easy to set up and use. It is known for its good performance and scalability, and has a large community of users and developers for support and resources. MySQL supports SQL (Structured Query Language) and is often used for web applications, mobile apps, and other software systems.\nPostgreSQL: PostgreSQL is an open-source relational database management system that is known for its powerful and flexible features. It has strong support for data integrity and consistency, and is well-suited for large-scale and complex systems. PostgreSQL supports SQL, JSON, and other data types, and provides advanced features such as constraints and triggers for data integrity.\nSQL Server: SQL Server is a commercial relational database management system developed and marketed by Microsoft. It is well-suited for large-scale and enterprise systems, and has a lot of features and tools that are designed to help with performance and scalability. SQL Server supports SQL, and it is often used for data warehousing and business intelligence.\nOracle: Oracle is a proprietary relational database management system that is powerful and feature-rich. It has strong support for data integrity and consistency, and has built-in tools and features to help with performance and scalability. Oracle supports SQL"}},"/docs/relational-databases/what-is-database":{"title":"What is Database ?","data":{"":"A database is like a big library where you can store and find information.Imagine you have a lot of books and you want to keep track of all of them, like the title, the author, and how many pages each book has. You could write this information down on pieces of paper and put them in a library. A database is like that, but it's on a computer and it can store much more information. It's like a digital library for all your important information.","database-management-system#Database management System":"If we think about our earlier example. Just like how a librarian helps you find the books you want and makes sure they are in the right place, the database management system helps you find the information you need and makes sure it is organized and easy to use. It also helps you add new information to the database, update or change information that is already there, and delete information that you don't need anymore. Think of it as a helper for your digital library to keep it neat and tidy.","how-sql-fits-with-the-database-management-system-dbms-and-database-db#How SQL fits with the database management system (DBMS) and database (DB)?":"SQL is a language that allows you to interact with the data stored in a database through a database management system (DBMS). DBMS is software that manages the database and uses SQL to communicate with it."}},"/docs/databases/what-is-database":{"title":"What is Database ?","data":{"":"A database is like a big library where you can store and find information.Imagine you have a lot of books and you want to keep track of all of them, like the title, the author, and how many pages each book has. You could write this information down on pieces of paper and put them in a library. A database is like that, but it's on a computer and it can store much more information. It's like a digital library for all your important information.","database-management-system#Database management System":"If we think about our earlier example. Just like how a librarian helps you find the books you want and makes sure they are in the right place, the database management system helps you find the information you need and makes sure it is organized and easy to use. It also helps you add new information to the database, update or change information that is already there, and delete information that you don't need anymore. Think of it as a helper for your digital library to keep it neat and tidy.","how-sql-fits-with-the-database-management-system-dbms-and-database-db#How SQL fits with the database management system (DBMS) and database (DB)?":"SQL is a language that allows you to interact with the data stored in a database through a database management system (DBMS). DBMS is software that manages the database and uses SQL to communicate with it."}},"/docs/algorithms/linear-search":{"title":"Linear Search","data":{"":"Linear search is a way to find something in a list. Imagine you have a list of your friends' names and you want to find your best friend's name in it. You would start at the first name and check if it's your best friend's name. If it's not, you would move on to the next name and check again. You would keep doing this until you find your best friend's name.For example, let's say your best friend's name is \"Emma\" and the list of your friends' names is [\"John\", \"Mike\", \"Emma\", \"Amy\", \"Kevin\"]. You would start with \"John\", then move on to \"Mike\", then \"Emma\" and you find your best friend's name.Linear search is a basic method but it can be slow if you have a large list, it's good for small lists or when you don't have a lot of data.","example#Example":"function linearSearch(list, value) {\nfor (let i = 0; i < list.length; i++) {\nif (list[i] === value) {\nreturn i;\n}\n}\nreturn -1;\n}\n\nlet friends = [\"John\", \"Mike\", \"Emma\", \"Amy\", \"Kevin\"];\nlet bestFriend = \"Emma\";\nlet index = linearSearch(friends, bestFriend);\nconsole.log(`${bestFriend} is at index ${index} in the list.`);\n\nIn this example, the function linearSearch() takes in two arguments: a list of friends and the name of the best friend you're looking for. It loops through the list, checking each element to see if it matches the value you're looking for. If it finds a match, it returns the index of that element in the list. If it doesn't find a match, it returns -1.In the last lines, we are creating an array of friends, a variable for our bestFriend and calling the function by passing those two variables as arguments. And we are logging a message to the console with the index of the best friend.You will see the output \"Emma is at index 2 in the list.\" in the console.","questions#Questions":"What is the time complexity of linear search?\nThe time complexity of linear search is O(n), where n is the number of elements in the list. This means that the time it takes to search through the list increases linearly with the size of the list."}},"/docs/algorithms/binary-search":{"title":"Binary Search","data":{"":"Imagine you have a really big book with lots of pages and you want to find a specific word or phrase in it. You could start at the first page and read every single page until you find the word you're looking for, but that would take a long time if the book is really big!A better way would be to use something called \"binary search\". With binary search, you start by looking at the middle page of the book. If the word you're looking for is on that page, you're done! But if it's not there, you can use the words on that page to figure out if the word you're looking for is in the first half of the book or the second half of the book.Let's say the word you're looking for is \"giraffe\", and the middle page has the word \"elephant\" on it. Since \"elephant\" comes after \"giraffe\" in the dictionary, you know that the word \"giraffe\" must be in the first half of the book. So now you can ignore the second half of the book, and look for \"giraffe\" in the first half of the book by again looking at the middle page.By doing this over and over, you can quickly narrow down where the word \"giraffe\" is in the book, and find it much faster than if you had to read every single page.","example-code-in-javascript#Example Code in JavaScript":"function binarySearch(list, target) {\nlet start = 0;\nlet end = list.length - 1;\nlet found = false;\n\nwhile (start <= end && !found) {\nlet middle = Math.floor((start + end) / 2);\nif (list[middle] === target) {\nfound = true;\n} else if (list[middle] < target) {\nstart = middle + 1;\n} else {\nend = middle - 1;\n}\n}\nreturn found;\n}","questions#Questions":"Can you explain the concept of binary search and how it's different from linear search?\nBinary search is a search algorithm that works on a sorted array or list. It works by repeatedly dividing the array in half until the target element is found. It's different from linear search, which simply checks each element in the array one by one until the target element is found. Binary search is more efficient because it cuts the search space in half with each iteration, making it an O(log n) algorithm, whereas linear search is O(n)."}},"/docs/algorithms/running-time":{"title":"Running Time","data":{"":"An algorithm is like a list of steps to solve a problem, like a recipe for making cookies. The time it takes to follow the steps and make the cookies is called the \"running time.\"There are several common running time algorithms, including:\nO(1): constant time: the running time remains the same, no matter how big the input is. Example: Accessing an element in an array at a specific index.\nO(log n): logarithmic time: the running time grows logarithmically with the size of the input. Example: Binary search.\nO(n): linear time: the running time grows linearly with the size of the input. Example: Linear search.\nO(n log n): log-linear time: the running time grows as the size of the input multiplied by the logarithm of the size of the input. Example: Mergesort.\nO(n^2): quadratic time: the running time grows as the square of the size of the input. Example: Bubble sort.\nO(2^n): exponential time: the running time grows quickly as the size of the input increases. Example: Brute-force search."}},"/docs/algorithms/selection-sort":{"title":"Selection Sort","data":{"":"Selection sorting is a special way of sorting things so they're in order. Let's say you have a pile of blocks, and you want to put them in order from shortest to tallest. The selection sort algorithm is like a game you can play to do that.Here's how you play:\nLook at all the blocks and find the shortest one.\nPick up the shortest block and put it at the beginning of a new pile.\nLook at the rest of the blocks and find the next shortest one.\nPick up the next shortest block and put it next to the first block in the new pile.\nKeep doing this until there are no more blocks left in the pile.\n\nNow, you have a new pile of blocks that are in order from shortest to tallest. That's the selection sort algorithm! It's a fun and easy way to sort things and put them in order."}},"/docs/angular":{"title":"Angular","data":{"":"So imagine you have a big notebook, and you want to share it with your friends. But, sometimes you make mistakes and draw something you don't like. With a notebook, you can't go back and erase just that one thing, you have to start a new notebook.\nA Version Control System is like a special notebook that keeps track of all the changes you make, so you can go back and look at them later. And, if you make a mistake, you can go back to an earlier version and start again from there. It's kind of like using the \"undo\" button on a computer.\nIt's also a way for multiple people to work on the same notebook at the same time, and it will keep track of who made what changes and when. That way, if two people draw on the same page at the same time, the Version Control System will figure out how to put the drawings together without making a mess.s","repo-hosting-services#Repo Hosting Services":"Okay, so you know how you share your notebook with your friends? Well, a Repo Hosting Service is like a big cabinet where you can put your notebook, and it will keep it safe and make it easy for your friends to find.\nIt's a place where you can store your notebook on the internet so that other people can access it from anywhere, even if they're not next to you. It's like a big library where you can put your notebook on a shelf and people can come and look at it or even borrow it to make their own copies.\nAnd, just like a library, there are many different Repo Hosting Services, and each one has its own set of rules and ways of doing things. Some are free, and others cost money. Some are for big groups, and others are for just a few friends.\nIt's a good way to share your notebook with people all around the world and work on it together.","git#Git":"Git is like a magic tool that helps you use a Version Control System. It's kind of like a special pen that you use to write in your notebook.\nWith it, you can tell your computer to take a picture of your notebook, so you can save it and go back to it later. You can also tell git to show you the differences between different pictures of your notebook, so you can see what has changed.\nIt also helps you share your notebook with your friends, by sending and receiving pictures of your notebook, so you can all work on the same notebook together. Git helps you keep your notebook organized and make sure you don't lose any of your work.\nJust like a pen, it is a tool that helps you write, save and share your work, in this case, it's the code.","start-git#Start Git":"To start using git, you first need to install it on your computer. You can download the appropriate version for your operating system from the official git website.\nOnce it is installed, you can use it in the command line to interact with your repository. The first step is to initialize a new repository. This can be done by navigating to the directory that you want to turn into a repository and running the command \"git init\".\nAfter that, you can start adding files to the repository by using the command \"git add\" followed by the file name, or you can use \"git add .\" to add all files in the current directory. You also need to commit the changes you made with the command \"git commit -m \"message\", where the message is a short description of the changes you made.\nYou can also connect your local repository to a remote repository like GitHub, GitLab or Bitbucket. This allows you to share your code with others, collaborate on projects and keep your local repository in sync with the remote repository.\nIt's important to note that it is a complex tool and these are just the basic commands to get started, there's a lot more to learn and explore about it, but with these commands, you should be able to start version controlling your code.","questions#Questions":"What is a Version Control System, and why is it important?\nA Version Control System (VCS) is a software tool that manages and keeps track of the changes made to files over time. It records the history of changes and allows users to revert to earlier versions of the files if needed.\n\nCan you explain the difference between git and a Repo Hosting Service?\nVCS tool that allows you to track and manage changes to files, while a Repo Hosting Service provides a platform to store and share those changes with others. Git provides the version control functionality and the Repo Hosting Service provides a place to store the codebase online, making it easily accessible to multiple users."}}}